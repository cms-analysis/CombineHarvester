<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>CombineHarvester: Python Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 70px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CombineHarvester
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('python-interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Python Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#py-constr-copy">Constructors and copying</a></li>
<li class="level1"><a href="#py-log-print">Logging and Printing</a></li>
<li class="level1"><a href="#py-datacards">Datacards</a><ul><li class="level2"><a href="#py-datacards-meta">Parsing specifying metadata</a></li>
<li class="level2"><a href="#py-datacards-pat-sub">Parsing with pattern substitution</a></li>
<li class="level2"><a href="#py-datacards-writing">Writing</a></li>
</ul>
</li>
<li class="level1"><a href="#py-filtering">Filtering</a></li>
<li class="level1"><a href="#py-sets">Set producers</a></li>
<li class="level1"><a href="#py-modifications">Modifications</a></li>
<li class="level1"><a href="#py-eval">Rate and shape evaluation</a></li>
<li class="level1"><a href="#py-creation">Datacard creation</a></li>
<li class="level1"><a href="#py-card-writer">Class: CardWriter</a></li>
<li class="level1"><a href="#py-bbbfactory">Class: BinByBinFactory</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_docs_PythonInterface"></a></p>
<p>The C++ CombineHarvester class and a number of other tools have a python interface available. The module containing this interface can be imported like any other CMSSW python module: </p><pre class="fragment">import CombineHarvester.CombineTools.ch as ch
</pre><p> The sections below summarise the methods that are currently supported.</p>
<h1><a class="anchor" id="py-constr-copy"></a>
Constructors and copying</h1>
<p>C++: </p><pre class="fragment">ch::CombineHarvester cb;
ch::CombineHarvester cb_shallow_copy = cb.cp();
ch::CombineHarvester cb_deep_copy = cb.deep();
</pre><p> Python: </p><pre class="fragment">cb = ch.CombineHarvester()
cb_shallow_copy = cb.cp()
cb_deep_copy = cb.deep()
</pre> <h1><a class="anchor" id="py-log-print"></a>
Logging and Printing</h1>
<p>C++: </p><pre class="fragment">cb.PrintAll();
cb.PrintObs();
cb.PrintProcs();
cb.PrintSysts();
cb.PrintParams();
cb.SetVerbosity(1);
cb.Verbosity();
</pre><p> Python: </p><pre class="fragment">cb.PrintAll()
cb.PrintObs()
cb.PrintProcs()
cb.PrintSysts()
cb.PrintParams()
cb.SetVerbosity(1)
cb.Verbosity()
</pre> <h1><a class="anchor" id="py-datacards"></a>
Datacards</h1>
<h2><a class="anchor" id="py-datacards-meta"></a>
Parsing specifying metadata</h2>
<p>C++: </p><pre class="fragment">cb.ParseDatacard("datacard.txt", "htt", "8TeV", "mt", 6, "125");
</pre><p> Python: </p><pre class="fragment">cb.ParseDatacard("datacard.txt", "htt", "8TeV", "mt", 6, "125")
</pre><p> Metadata parameters also have default values and can be named explicitly: </p><pre class="fragment">cb.ParseDatacard("datacard.txt", analysis = "htt", mass = "125")
</pre> <h2><a class="anchor" id="py-datacards-pat-sub"></a>
Parsing with pattern substitution</h2>
<p>C++: </p><pre class="fragment">cb.ParseDatacard("htt_mt_8_8TeV.txt", "$ANALYSIS_$CHANNEL_$BINID_$ERA.txt");
</pre><p> Python (note the different method name): </p><pre class="fragment">cb.QuickParseDatacard("htt_mt_8_8TeV.txt", "$ANALYSIS_$CHANNEL_$BINID_$ERA.txt")
</pre> <h2><a class="anchor" id="py-datacards-writing"></a>
Writing</h2>
<p>C++: </p><pre class="fragment">cb.WriteDatacard("card.txt", "file.root"); // or
...
TFile out("file.root", "recreate");
cb.WriteDatacard("card.txt", out);
</pre><p> Python (second method not yet available): </p><pre class="fragment">cb.WriteDatacard("card.txt", "file.root")
</pre> <h1><a class="anchor" id="py-filtering"></a>
Filtering</h1>
<p>All of the basic filter methods can be called and chained in a similar way in both interfaces. For example:</p>
<p>C++: </p><pre class="fragment">cb.bin({"muTau_vbf"}).era({"7TeV", "8TeV"}).signals().process({"ggH"}, false);
</pre><p> Python: </p><pre class="fragment">cb.bin(['muTau_vbf']).era(['7TeV', '8TeV']).signals().process(['ggH'], False)
</pre><p> The generic filter methods (FilterAll, FilterObs, FilterProcs, FilterSysts) have also been adapted to accept python functions, e.g.</p>
<p>C++: </p><pre class="fragment">cb.FilterAll([](ch::Object const* obj) {
  return obj-&gt;mass() == "110" || obj-&gt;mass() == "145";
  });
</pre><p> Python: </p><pre class="fragment">cb.FilterAll(lambda obj : obj.mass() in ['110', '145'])
</pre> <h1><a class="anchor" id="py-sets"></a>
Set producers</h1>
<p>All basic set producer methods are available.</p>
<p>C++: </p><pre class="fragment">set&lt;string&gt; bins = cb.bin_set();
for (auto p : cb.process_set()) {
  ...
}
</pre><p> Python: </p><pre class="fragment">bins = cb.bin_set()
for p in cb.process_set():
    ...
</pre><p> The generic methods are available too, and accept a generic function object.</p>
<p>C++: </p><pre class="fragment">set&lt;string&gt; bins = cb.SetFromAll(std::mem_fn(&amp;ch::Object::bin));
set&lt;string&gt; some_set = cb.SetFromProcs([](ch::Process const* p) {
        return p-&gt;process() + "_" + p-&gt;bin();
    });
</pre><p> Python: </p><pre class="fragment">bins = cb.SetFromAll(ch.Object.bin)
some_set = cb.SetFromProcs(lambda x : x.process() + '_' + x.bin())
</pre> <h1><a class="anchor" id="py-modifications"></a>
Modifications</h1>
<p>The <code>GetParameter</code>, and <code>UpdateParameters</code> methods that use <code><a class="el" href="classch_1_1_parameter.html">ch::Parameter</a></code> objects are not available (and may be deprecated soon anyway). The <code>UpdateParameters</code> method taking a <code>RooFitResult</code> is available however.</p>
<p>C++: </p><pre class="fragment">TFile f("mlfit.root");
RooFitResult *res = (RooFitResult*)f.Get("fit_s");
cb.UpdateParameters(*res);
</pre><p> Python: </p><pre class="fragment">import ROOT as R
f = R.TFile("mlfit.root")
res = f.Get("fit_s")
cb.UpdateParameters(res)
</pre><p> The generic ForEach methods are also available and can take arbitrary python functions as input.</p>
<p>C++: </p><pre class="fragment">void SwitchToSignal(ch::Process const* p) {
    if (p-&gt;process() == "ggH_hww125") p-&gt;set_signal(true);
}
cb.ForEachProc(SwitchToSignal);
</pre><p> Python: </p><pre class="fragment">def SwitchToSignal(p):
    if p.process() == 'ggH_hww125': p.set_signal(True)
cb.ForEachProc(SwitchToSignal)
</pre> <h1><a class="anchor" id="py-eval"></a>
Rate and shape evaluation</h1>
<p>All methods are supported with a similar interface.</p>
<p>C++: </p><pre class="fragment">double a = cb.GetObservedRate();
double b = cb.GetRate();
double c = cb.GetUncertainty();
double d = cb.GetUncertainty(res, 500);
TH1F e = cb.GetObservedShape();
TH1F f = cb.GetShape();
TH1F g = cb.GetShapeWithUncertainty(res, 500);
</pre><p> Python: </p><pre class="fragment">import ROOT as R
a = cb.GetObservedRate()
b = cb.GetRate()
c = cb.GetUncertainty()
d = cb.GetUncertainty(res, 500)
e = cb.GetObservedShape()
f = cb.GetShape()
g = cb.GetShapeWithUncertainty(res, 500)
</pre> <h1><a class="anchor" id="py-creation"></a>
Datacard creation</h1>
<p>Creating observation and process entries is supported.</p>
<p>C++: </p><pre class="fragment">cb.AddObservations({"*"}, {"htt"}, {"8TeV"}, {"mt", "et"}, {{0, "0jet"}, {1, "1jet"}})
cb.AddProcesses({"*"}, {"htt"}, {"8TeV"}, {"mt", "et"}, {"ZTT", "ZL", "ZJ"}, {{0, "0jet"}, {1, "1jet"}}, false)
</pre><p> Python: </p><pre class="fragment">cb.AddObservations(['*'], ['htt'], ['8TeV'], ['mt', 'et'], [(0, "0jet"), (1, "1jet")])
cb.AddProcesses(['*'], ['htt'], ['8TeV'], ['mt', 'et'], ['ZTT', 'ZL', 'ZJ'], [(0, "0jet"), (1, "1jet")], False)
## or with default values:
cb.AddProcesses(procs = ['ZTT', 'ZL', ZJ'], bin = [(0, "0jet"), (1, "1jet")], signal=False)
</pre><p> As is bin-by-bin creating and merging, but note that these methods have been deprecated in favour of the standalone <a class="el" href="classch_1_1_bin_by_bin_factory.html" title="Merges bin uncertainties and creates bin-by-bin statistical uncertainties.">ch::BinByBinFactory</a> class (see below).</p>
<p>C++: </p><pre class="fragment">cb.MergeBinErrors(0.1, 0.5);
cb.AddBinByBin(0.1, true, cb);
</pre><p> Python: </p><pre class="fragment">cb.MergeBinErrors(0.1, 0.5)
cb.AddBinByBin(0.1, True, cb)
</pre><p> The creation of Systematic entries with the <code>AddSyst</code> method is supported, though has a slightly different syntax due to the heavy template usage in the C++ version.</p>
<p>C++: </p><pre class="fragment">cb.cp().process({"WH", "ZH"}).AddSyst(
  cb, "QCDscale_VH", "lnN", SystMap&lt;channel, era, bin_id&gt;::init
    ({"mt"}, {"7TeV", "8TeV"},  {1, 2},               1.010)
    ({"mt"}, {"7TeV", "8TeV"},  {3, 4, 5, 6, 7},      1.040)
    ({"et"}, {"7TeV"},          {1, 2, 3, 5, 6, 7},   1.040)
    ({"et"}, {"8TeV"},          {1, 2},               1.010)
    ({"et"}, {"8TeV"},          {3, 5, 6, 7},         1.040));
</pre><p> Python: </p><pre class="fragment">cb.cp().process(['WH', 'ZH']).AddSyst(
  cb, "QCDscale_VH", "lnN", ch.SystMap('channel', 'era', 'bin_id')
    (['mt'], ['7TeV', '8TeV'],  [1, 2],               1.010)
    (['mt'], ['7TeV', '8TeV'],  [3, 4, 5, 6, 7],      1.040)
    (['et'], ['7TeV'],          [1, 2, 3, 5, 6, 7],   1.040)
    (['et'], ['8TeV'],          [1, 2],               1.010)
    (['et'], ['8TeV'],          [3, 5, 6, 7],         1.040))
</pre><p> Note that asymmetric uncertainties are created in a different way in Python or C++:</p>
<p>C++: </p><pre class="fragment">cb.cp().process({"WH", "ZH"}).AddSyst(
  cb, "QCDscale_VH", "lnN", SystMapAsymm&lt;channel, era, bin_id&gt;::init
    ({"mt"}, {"7TeV", "8TeV"}, {1, 2}, 0.91, 1.05));
</pre><p> Python: </p><pre class="fragment">cb.cp().process(['WH', 'ZH']).AddSyst(
  cb, "QCDscale_VH", "lnN", ch.SystMap('channel', 'era', 'bin_id')
    (['mt'], ['7TeV', '8TeV'], [1, 2], (0.91, 1.05)))
</pre><p> The ExtractPdfs, ExtractData and AddWorkspace methods are not currently supported.</p>
<h1><a class="anchor" id="py-card-writer"></a>
Class: CardWriter</h1>
<p>The <a class="el" href="classch_1_1_card_writer.html" title="Automates the writing of datacards into directory structures.">ch::CardWriter</a> class has an identical interface in python.</p>
<p>C++: </p><pre class="fragment">ch::CardWriter writer("$TAG/$MASS/$ANALYSIS_$CHANNEL_$BINID_$ERA.txt",
                      "$TAG/common/$ANALYSIS_$CHANNEL.input_$ERA.root");
writer.WriteCards("LIMITS/cmb", cb);
</pre><p> Python: </p><pre class="fragment">writer = ch.CardWriter('$TAG/$MASS/$ANALYSIS_$CHANNEL_$BINID_$ERA.txt',
                       '$TAG/common/$ANALYSIS_$CHANNEL.input_$ERA.root')
writer.WriteCards('LIMITS/cmb', cb)
</pre> <h1><a class="anchor" id="py-bbbfactory"></a>
Class: BinByBinFactory</h1>
<p>The <a class="el" href="classch_1_1_bin_by_bin_factory.html" title="Merges bin uncertainties and creates bin-by-bin statistical uncertainties.">ch::BinByBinFactory</a> class has an identical interface in python.</p>
<p>C++: </p><pre class="fragment">auto bbb = ch::BinByBinFactory()
    .SetAddThreshold(0.1)
    .SetMergeThreshold(0.5)
    .SetFixNorm(true);
bbb.MergeBinErrors(cb.cp().backgrounds());
bbb.AddBinByBin(cb.cp().backgrounds(), cb);
</pre><p> Python: </p><pre class="fragment">bbb = ch.BinByBinFactory()
bbb.SetAddThreshold(0.1).SetMergeThreshold(0.5).SetFixNorm(True)
bbb.MergeBinErrors(cb.cp().backgrounds())
bbb.AddBinByBin(cb.cp().backgrounds(), cb)
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
</body>
</html>
