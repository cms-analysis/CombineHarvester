<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>CombineHarvester: RooMorphingPdf</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 70px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CombineHarvester
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('intro_morph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">RooMorphingPdf </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_RooMorphingPdf"></a></p>
<h1><a class="anchor" id="BuildRooMorph"></a>
BuildRooMorphing function</h1>
<p><b>File</b>: <a class="el" href="_morph_functions_8cc.html">CombinePdfs/src/MorphFunctions.cc</a></p>
<p>The PDF which is used for the signal is a custom RooFit PDF. Its application is made via the datacard production code, with a call to a function named BuildRooMorphing. Here we highlight some of the important features of this function. For a greater level of detail we recommend the reader look at the code itself, which is well commented.</p>
<p>The arguments to the function are as follows:</p>
<div class="fragment"><div class="line">std::string <a class="code" href="namespacech.html#a011bcc8eb52bfa118fd44ade245e9e45">BuildRooMorphing</a>(RooWorkspace&amp; ws, CombineHarvester&amp; cb,</div>
<div class="line">                      std::string <span class="keyword">const</span>&amp; bin, std::string <span class="keyword">const</span>&amp; process,</div>
<div class="line">                      RooAbsReal&amp; mass_var, std::string norm_postfix,</div>
<div class="line">                      <span class="keywordtype">bool</span> allow_morph, <span class="keywordtype">bool</span> verbose, <span class="keywordtype">bool</span> force_template_limit, TFile * file) {</div>
<div class="ttc" id="anamespacech_html_a011bcc8eb52bfa118fd44ade245e9e45"><div class="ttname"><a href="namespacech.html#a011bcc8eb52bfa118fd44ade245e9e45">ch::BuildRooMorphing</a></div><div class="ttdeci">std::string BuildRooMorphing(RooWorkspace &amp;ws, CombineHarvester &amp;cb, std::string const &amp;bin, std::string const &amp;process, RooAbsReal &amp;mass_var, std::string norm_postfix, bool allow_morph, bool verbose, bool force_template_limit=false, TFile *file=nullptr)</div><div class="ttdoc">[part1]</div><div class="ttdef"><b>Definition:</b> <a href="_morph_functions_8cc_source.html#l00020">MorphFunctions.cc:20</a></div></div>
</div><!-- fragment --><p> The options to this function are as follows:</p>
<ul>
<li>A RooWorkspace to be passed to the function.</li>
<li>The Combine Harvester instance, already setup with all the necessary channels, categories and systematics as described in the previous sections.</li>
<li>The process upon which the morphing is to be applied, each signal process.</li>
<li>A RooAbsReal which controls the signal mass.</li>
<li>The "norm_prefix" is an optional additional prefix to add to the normalisation term controlling the PDF.</li>
<li>The "allow_morph" option controls whether the PDF is designed such that for masses inbetween those for which signal templates are available the signal yield and shape are taken via interpolation, or whether the nearest template is simply taken.</li>
<li>Simply controls the verbose output of the code</li>
<li>The option "force_template_limit" is an optional setting to force the normalisation of the PDF to go to zero outside of the range of available masses.</li>
<li>An optional TFile to contain debug information.</li>
</ul>
<p>The first step of the function is to work out the list of available masspoints for the signal process, and sort and count them:</p>
<div class="fragment"><div class="line">  <span class="comment">// Get a vector of the mass values</span></div>
<div class="line">  vector&lt;string&gt; m_str_vec = <a class="code" href="namespacech.html#a5e23234ab65cfa48c99b83d94e291125">Set2Vec</a>(cb_bp.SetFromProcs(</div>
<div class="line">      std::mem_fn(&amp;<a class="code" href="classch_1_1_object.html#ae2f9e80af391e105a6b6bc27107e3c9e">ch::Process::mass</a>)));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We now sort these based on numerical value, hence the lexical_cast to double</span></div>
<div class="line">  <span class="comment">// At the moment this also serves as our check that all mass values are</span></div>
<div class="line">  <span class="comment">// float-convertible, as an exception will be thrown by lexical_cast if not.</span></div>
<div class="line">  std::sort(m_str_vec.begin(), m_str_vec.end(),</div>
<div class="line">    [](<span class="keywordtype">string</span> <span class="keyword">const</span>&amp; s1, <span class="keywordtype">string</span> <span class="keyword">const</span>&amp; s2) {</div>
<div class="line">      return lexical_cast&lt;double&gt;(s1) &lt; lexical_cast&lt;double&gt;(s2);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Convert the sorted vector of mass strings to an actual vector of doubles</span></div>
<div class="line">  vector&lt;double&gt; m_vec;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; s : m_str_vec) {</div>
<div class="line">    <span class="keywordflow">if</span> (verbose) std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt;&gt;&gt; Mass point: &quot;</span> &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    m_vec.push_back(lexical_cast&lt;double&gt;(s));</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// So, we have m mass points to consider</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> m = m_vec.size();</div>
<div class="ttc" id="aclassch_1_1_object_html_ae2f9e80af391e105a6b6bc27107e3c9e"><div class="ttname"><a href="classch_1_1_object.html#ae2f9e80af391e105a6b6bc27107e3c9e">ch::Object::mass</a></div><div class="ttdeci">virtual std::string const  &amp; mass() const</div><div class="ttdef"><b>Definition:</b> <a href="_object_8h_source.html#l00038">Object.h:38</a></div></div>
<div class="ttc" id="anamespacech_html_a5e23234ab65cfa48c99b83d94e291125"><div class="ttname"><a href="namespacech.html#a5e23234ab65cfa48c99b83d94e291125">ch::Set2Vec</a></div><div class="ttdeci">std::vector&lt; T &gt; Set2Vec(std::set&lt; T &gt; const &amp;in)</div><div class="ttdef"><b>Definition:</b> <a href="_utilities_8h_source.html#l00101">Utilities.h:101</a></div></div>
</div><!-- fragment --><p> Then it is necessary to track all the information on the systematics affecting the signal process. This is done separately for the shape and normalisation systematics. After some manipulation of this information (including special treatment for the case where a shape systematic also alters the normalisation, i.e. has a value different from 1.00), it is possible to build a RooArgList of the parameters controlling the vertical template morphing which is internally used by combine to apply the effect of the shape systematics to the signal.</p>
<div class="fragment"><div class="line">  <span class="comment">// We need to build a RooArgList of the vertical morphing parameters for the</span></div>
<div class="line">  <span class="comment">// vertical-interpolation pdf - this will be the same for each mass point so</span></div>
<div class="line">  <span class="comment">// we only build it once</span></div>
<div class="line">  RooArgList ss_list;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> ssi = 0; ssi &lt; ss; ++ssi) {</div>
<div class="line">    <span class="comment">// Make the nuisance parameter var. We use shared_ptrs here as a convenience</span></div>
<div class="line">    <span class="comment">// because they will take care of automatically cleaning up the memory at</span></div>
<div class="line">    <span class="comment">// the end</span></div>
<div class="line">    ss_scale_var_arr[ssi] =</div>
<div class="line">        std::make_shared&lt;RooRealVar&gt;(ss_vec[ssi].c_str(), <span class="stringliteral">&quot;&quot;</span>, 0);</div>
<div class="line">    <span class="comment">// We&#39;ll make a quick check that the scale factor for this systematic is the</span></div>
<div class="line">    <span class="comment">// same for all mass points. We could do a separate scaling at each mass</span></div>
<div class="line">    <span class="comment">// point but this would create a lot of complications</span></div>
<div class="line">    set&lt;double&gt; scales;</div>
<div class="line">    <span class="comment">// Insert the scale from each mass point into the set, if it has a size</span></div>
<div class="line">    <span class="comment">// larger than one at the end then we have a problem!</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> mi = 0; mi &lt; m; ++mi) {</div>
<div class="line">      scales.insert(ss_arr[ssi][mi]-&gt;scale());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (scales.size() &gt; 1) {</div>
<div class="line">      <span class="comment">// Don&#39;t let the user proceed, we can&#39;t build the model they want</span></div>
<div class="line">      std::runtime_error(<a class="code" href="_logging_8h.html#ab140ae8826e1f99c5aa0e920a9c13112">FNERROR</a>(</div>
<div class="line">          <span class="stringliteral">&quot;Shape morphing parameters that vary with mass are not allowed&quot;</span>));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Everything ok, set the scale value in its array</span></div>
<div class="line">      ss_scale_arr[ssi] = *(scales.begin());</div>
<div class="line">      <span class="comment">// Handle the case where the scale factor is != 1</span></div>
<div class="line">      <span class="keywordflow">if</span> (std::fabs(ss_scale_arr[ssi] - 1.0) &gt; 1E-6) {</div>
<div class="line">        ss_must_scale_arr[ssi] = <span class="keyword">true</span>;</div>
<div class="line">        <span class="comment">// Build the RooConstVar with the value of the scale factor</span></div>
<div class="line">        ss_scale_fac_arr[ssi] = std::make_shared&lt;RooConstVar&gt;(</div>
<div class="line">            TString::Format(<span class="stringliteral">&quot;%g&quot;</span>, ss_scale_arr[ssi]), <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">            ss_scale_arr[ssi]);</div>
<div class="line">        <span class="comment">// Create the product of the floating nuisance parameter and the</span></div>
<div class="line">        <span class="comment">// constant scale factor</span></div>
<div class="line">        ss_scale_prod_arr[ssi] = std::make_shared&lt;RooProduct&gt;(</div>
<div class="line">            ss_vec[ssi] + <span class="stringliteral">&quot;_scaled_&quot;</span> + key, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">            RooArgList(*(ss_scale_var_arr[ssi]), *(ss_scale_fac_arr[ssi])));</div>
<div class="line">        <span class="comment">// Add this to the list</span></div>
<div class="line">        ss_list.add(*(ss_scale_prod_arr[ssi]));</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// If the scale factor is 1.0 then we just add the nuisance parameter</span></div>
<div class="line">        <span class="comment">// directly to our list</span></div>
<div class="line">        ss_list.add(*(ss_scale_var_arr[ssi]));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="ttc" id="a_logging_8h_html_ab140ae8826e1f99c5aa0e920a9c13112"><div class="ttname"><a href="_logging_8h.html#ab140ae8826e1f99c5aa0e920a9c13112">FNERROR</a></div><div class="ttdeci">#define FNERROR(x)</div><div class="ttdef"><b>Definition:</b> <a href="_logging_8h_source.html#l00009">Logging.h:9</a></div></div>
</div><!-- fragment --><p> Note that the above code takes care over the possibility that the shape systematics are not the same for all masspoints - this is not currently supported in this function. The created "ss_list" is used later to create the vertical template morphing PDFs.</p>
<p>For the normalisation systematics we must consider separately the two cases: 1) in the first case the uncertainty is the same for each masspoint, so we can leave this in the datacard in the usual way, but in case 2) where the uncertainty is not the same for each masspoint, we have to include this information in the signal PDF by creating a RooFit object that makes the uncertainty a function off mass. Finally a list is built of all objects required for the interpolation.</p>
<p>A 1D spline is built directly from the array of rates and masses:</p>
<div class="fragment"><div class="line">  RooSpline1D rate_spline(<span class="stringliteral">&quot;interp_rate_&quot;</span>+key, <span class="stringliteral">&quot;&quot;</span>, mass_var, </div>
<div class="line">                        force_template_limit ? m+2 : m, </div>
<div class="line">                        force_template_limit ? new_m_vec.data() : m_vec.data(),</div>
<div class="line">                        force_template_limit ? new_rate_arr.data() : rate_arr.data(),</div>
<div class="line">                        interp);</div>
</div><!-- fragment --><p> Here the option "force_template_limit" allows the user to use an alternative rate array where the rate falls to 0 for masses only very slightly outside of those in the mass array. Then a normalisation term is built which contains all the terms which go into the normalisation - the original rate and the normalisation systematics. The array of vertical morphing PDFs is also built using the information from earlier. Finally, the RooMorphingPdf is built with the following obtained information:</p>
<div class="fragment"><div class="line">  RooMorphingPdf morph_pdf(morph_name, <span class="stringliteral">&quot;&quot;</span>, xvar, mass_var, vpdf_list,</div>
<div class="line">                           m_vec, allow_morph, *(data_hist.GetXaxis()),</div>
<div class="line">                           *(proc_hist.GetXaxis()));</div>
</div><!-- fragment --><p> with the arguments:</p><ul>
<li>xvar : the fixed "CMS_th1x" x-axis variable with uniform integer binning</li>
<li>mass_var: the floating mass value for the interpolation</li>
<li>vpdf_list: the list of vertical-interpolation pdfs</li>
<li>m_vec: the corresponding list of mass points</li>
<li>allow_morph: if false will just evaluate to the closest pdf in mass</li>
<li>data_hist.GetXaxis(): The original (non-uniform) target binning</li>
<li>proc_hist.GetXaxis(): The original (non-uniform) morphing binning</li>
</ul>
<p>The final two arguments are needed to support the possibility that the signal template being interpolated has a finer binning than the target binning for the fit. in order to avoid known problems with the RMS of a peaking distribution not being morphed smoothly from mass point to mass point if the binning is too wide. A RooProduct is added for the normalisation of this PDF:</p>
<div class="fragment"><div class="line">  RooProduct morph_rate(morph_name + <span class="stringliteral">&quot;_&quot;</span> + TString(norm_postfix), <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                        rate_prod);</div>
</div><!-- fragment --><p> The creation of this term is very important. When building the workspace, this term will be searched for and tied to the PDF. It is possible at the workspace building step to add additional terms to those normalisation term, for example a scaling for cross-section times branching ratio. Example usage of this will be discussed later.</p>
<p>The final step in the function is to tidy up the CH instance before it is returned to the main code to write out the datacards. The signal yield in the datacards is replaced with a single value of 1.0, such that the normalisation will now be read from the normalisation object just created.</p>
<h1><a class="anchor" id="SMMorph"></a>
Example usage for SM analysis</h1>
<p>The code to produce SM datacards is almost exactly the same as the example described previously with the exception of a few additional lines to call the BuildRooMorphing function. The call to BuildRooMorphing is as follows:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">bool</span> do_morphing = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (do_morphing) {</div>
<div class="line">    <span class="comment">// RooMsgService::instance().setGlobalKillBelow(RooFit::WARNING);</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> chn : chns) {</div>
<div class="line">      <span class="keyword">auto</span> bins = cb.cp().channel({chn}).bin_set();</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> bin : bins) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : sig_procs) {</div>
<div class="line">          <a class="code" href="namespacech.html#a011bcc8eb52bfa118fd44ade245e9e45">ch::BuildRooMorphing</a>(ws, cb, bin, p, mh, <span class="stringliteral">&quot;norm&quot;</span>,</div>
<div class="line">                               can_morph[chn], <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">nullptr</span> <span class="comment">/*&amp;demo*/</span>);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// demo.Close();</span></div>
<div class="line">    cb.AddWorkspace(ws);</div>
<div class="line">    cb.cp().signals().ExtractPdfs(cb, <span class="stringliteral">&quot;htt&quot;</span>, <span class="stringliteral">&quot;$BIN_$PROCESS_morph&quot;</span>);</div>
</div><!-- fragment --><p> A single call is made for each signal process of each channel and category. The produced workspace is then imported into the CH instance and the created PDFs extracted. The workspace is stored in the shape file created for the limit calculations alongside the text datacards.</p>
<p>For cases like the SM analysis, this method can be used simply to produce one combined workspace for all masses, making the mass a continous parameter of the workspace. The rest of the calculations of the statistical results on the workspace are unchanged, except for the requirement to tell combine to fix the mass rather than float it. The workspace is build using the command:</p>
<p>text2workspace.py -b combinedCard.txt -o combinedCard.root &ndash;default-morphing shape2</p>
<p>Note that mass is not specified here, since we want to build a combined workspace for all possible masses. Then, to run the maximum likelihood fit for a given mass:</p>
<p>combine -M MaxLikelihoodFit &ndash;freezeNuisances MH -m 125 combinedCard.root</p>
<p>where in this case the mass must be specified.</p>
<h1><a class="anchor" id="MSSMMorph"></a>
Creating 1 or 3 Higgs bosons for an MSSM analysis</h1>
<p>For an MSSM or 2HDM interpretation, datacards must be setup containing 3 neutral Higgs bosons. The extension of the previous description to create datacards with three Higgs bosons in and a signal PDF for each is simple:</p>
<div class="fragment"></div><!-- fragment --><p> In this case the BuildRooMorphing function is passed the signal process corresponding to each of the three Higgs bosons, each controlled by their separate mass terms. Note the option "mass", which if set to "MH" will only build the datacards with one Higgs boson - this is reserved for the case of running the single resonance model independent limits and will instead place only one Higgs boson in the datacards.</p>
<h1><a class="anchor" id="MSSMModel"></a>
Applying a model at text2workspace step</h1>
<p>Having produced datacards containing signal PDFs for the appropriate number of Higgs bosons, we can go one step further and make extra use of the normalisation term associated with the PDFs. One specific use of this, as discussed in the introduction, is in the model dependent exclusions provided for example in the MSSM H-&gt;tautau analysis. In this case, each point in mA-tanb phase space has a different signal model containing contributions from the three Higgs bosons. At each point the masses of the Higgs bosons and the cross-sections times branching ratios are different. The normal procedure in this case would be to produce a workspace for each model point with a specific signal template built and added by hand.</p>
<p>Now that we have RooMorphingPdfs we can do this in a more clever way, by attaching terms controlling the normalisation of the signal to its normalisation term. This can be done within the text2workspace.py step, where the .txt datacard is converted into a RooWorkspace as input to combine. In this step, it is possible to apply a physics model which performs some scaling and manipulation to the different quantities in the datacards. By designing an appropriate physics model, we can add terms to the normalisation to control the cross section times branching ratio of the three Higgs bosons. These can be added as a function of mA and tanb which can be made parameters of the workspace as RooRealVars:</p>
<div class="fragment"><div class="line">                self.doHistFunc(<span class="stringliteral">&#39;mH&#39;</span>, f.Get(hd[<span class="stringliteral">&#39;mH&#39;</span>]), pars)</div>
<div class="line">                self.doHistFunc(<span class="stringliteral">&#39;mh&#39;</span>, f.Get(hd[<span class="stringliteral">&#39;mh&#39;</span>]), pars)</div>
</div><!-- fragment --><p> The histograms containing the information on the different cross-sections and branching ratios are included as TH2Ds inside a file for a particular model. These are read in and turned into a RooHistFunc via a helper function called doHistFunc:</p>
<div class="fragment"><div class="line">    <span class="keyword">def </span>doHistFunc(self, name, hist, varlist, interpolate=0):</div>
<div class="line">        <span class="stringliteral">&quot;method to conveniently create a RooHistFunc from a TH1/TH2 input&quot;</span></div>
<div class="line">        print(<span class="stringliteral">&#39;Doing histFunc %s...&#39;</span> % name)</div>
<div class="line">        <span class="keywordflow">if</span> self.dbg_file:</div>
<div class="line">            self.dbg_file.WriteTObject(hist, name)</div>
<div class="line">        <span class="keywordflow">if</span> self.mk_plots:</div>
<div class="line">            canv = ROOT.TCanvas(name, name)</div>
<div class="line">            pads = plot.OnePad()</div>
<div class="line">            hist.GetXaxis().SetTitle(varlist[0].GetTitle())</div>
<div class="line">            hist.GetYaxis().SetTitle(varlist[1].GetTitle())</div>
<div class="line">            hist.Draw(<span class="stringliteral">&#39;COLZ&#39;</span>)</div>
<div class="line">            plot.DrawTitle(pads[0], name, 3)</div>
<div class="line">            canv.Print(<span class="stringliteral">&#39;model_&#39;</span>+name+<span class="stringliteral">&#39;.pdf&#39;</span>)</div>
<div class="line">            canv.Print(<span class="stringliteral">&#39;model_&#39;</span>+name+<span class="stringliteral">&#39;.png&#39;</span>)</div>
<div class="line">            pads[0].SetLogz(<span class="keyword">True</span>)</div>
<div class="line">            canv.Print(<span class="stringliteral">&#39;model_&#39;</span>+name+<span class="stringliteral">&#39;_log.pdf&#39;</span>)</div>
<div class="line">            canv.Print(<span class="stringliteral">&#39;model_&#39;</span>+name+<span class="stringliteral">&#39;_log.png&#39;</span>)</div>
<div class="line">        dh = ROOT.RooDataHist(<span class="stringliteral">&#39;dh_%s&#39;</span>%name, <span class="stringliteral">&#39;dh_%s&#39;</span>%name, ROOT.RooArgList(*varlist), ROOT.RooFit.Import(hist))</div>
<div class="line">        hfunc = ROOT.RooHistFunc(name, name, ROOT.RooArgSet(*varlist), dh)</div>
<div class="line">        hfunc.setInterpolationOrder(interpolate)</div>
<div class="line">        self.modelBuilder.out._import(hfunc, ROOT.RooFit.RecycleConflictNodes())</div>
<div class="line">        <span class="keywordflow">return</span> self.modelBuilder.out.function(name)</div>
</div><!-- fragment --><p> Note the option 'interpolate' which is off by default - this allows the possibility of interpolating the model inputs to reach values beyond the granularity that is provided.</p>
<p>RooHistFuncs are then built for the mass terms controlling the two Higgs bosons which are not the A boson (since this is already controlled by the parameter mA, as well as the cross-section and branching ratio, for example using terms:</p>
<div class="fragment"><div class="line">            <span class="keywordflow">for</span> X <span class="keywordflow">in</span> [<span class="stringliteral">&#39;h&#39;</span>, <span class="stringliteral">&#39;H&#39;</span>, <span class="stringliteral">&#39;A&#39;</span>]:</div>
<div class="line">                self.doHistFunc(<span class="stringliteral">&#39;xs_gg%s_%s&#39;</span> % (X, era), f.Get(hd[<span class="stringliteral">&#39;xs_gg%s&#39;</span>%X]), pars)</div>
<div class="line">                <span class="keywordflow">if</span> self.ggHatNLO != <span class="keywordtype">None</span>:</div>
<div class="line">                    <span class="comment">#import Yukawa coupling factors of given scenario</span></div>
<div class="line">                    self.doHistFunc(<span class="stringliteral">&#39;Yt_MSSM_%s&#39;</span> % (X), f.Get(<span class="stringliteral">&#39;rescale_gt_%s&#39;</span>%X), pars)</div>
<div class="line">                    self.doHistFunc(<span class="stringliteral">&#39;Yb_MSSM_%s&#39;</span> % (X), f.Get(<span class="stringliteral">&#39;rescale_gb_%s&#39;</span>%X), pars)</div>
<div class="line">                    <span class="comment">#import xsec fractions keeping the Yukawa coupling factors from the step before</span></div>
<div class="line">                    self.add_ggH_at_NLO(<span class="stringliteral">&#39;xs_gg{X}{LC}_%s&#39;</span> %era, X)</div>
</div><!-- fragment --><p> In this code snippet, 'era' controls the centre of mass energy of the model, currently either 7TeV, 8TeV or 13TeV. Note that theoretical uncertainties, which are also provided from the model inputs as a function of mA and tanb, are applied at this stage as well by building the relevant terms and adding them to the workspace. Finally the relevant parameters are combined to give a complete term used to control the normalisation of the signal. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
</body>
</html>
