<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CombineHarvester: Examples Part I</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 70px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CombineHarvester
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('intro1.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Examples Part I </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ex1-p1">Parsing a single card </a></li>
<li class="level1"><a href="#ex1-p2">Parsing multiple cards </a></li>
<li class="level1"><a href="#ex1-p3">Filtering </a></li>
<li class="level1"><a href="#ex1-p4">Yields, copying and sets </a></li>
</ul>
</div>
<div class="textblock"><p><b>File</b>: CombineTools/bin/Example1.cpp</p>
<p>In this example we use CombineHarvester to parse an existing datacard and then extract information from it. Open the file above and take a look at the source code. To run the example, first make sure the code has been compiled with <code>scram</code>: </p><pre class="fragment">cd $CMSSW_BASE/src
scram b -j4
Example1
</pre><h1><a class="anchor" id="ex1-p1"></a>
Parsing a single card </h1>
<p>In the first part we locate and open a single text datacard file:</p>
<div class="fragment"><div class="line">  <span class="comment">// Use the CMSSW_BASE environment variable to get the full path to the auxiliaries folder</span></div>
<div class="line">  <span class="keywordtype">string</span> in_dir = string(getenv(<span class="stringliteral">&quot;CMSSW_BASE&quot;</span>)) + <span class="stringliteral">&quot;/src/auxiliaries/datacards/sm/htt_mt/&quot;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create a new CombineHarvester instance</span></div>
<div class="line">  <a class="code" href="classch_1_1_combine_harvester.html">ch::CombineHarvester</a> cmb1;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Call the `ParseDatacard` method specifying the path to the text file and the additional</span></div>
<div class="line">  <span class="comment">// metadata we want to associate with it</span></div>
<div class="line">  cmb1.<a class="code" href="classch_1_1_combine_harvester.html#aa65fe68ae736e6b612a9c35f42adf02f">ParseDatacard</a>(in_dir + <span class="stringliteral">&quot;htt_mt_6_8TeV-125.txt&quot;</span>, <span class="stringliteral">&quot;htt&quot;</span>, <span class="stringliteral">&quot;8TeV&quot;</span>, <span class="stringliteral">&quot;mt&quot;</span>, 6, <span class="stringliteral">&quot;125&quot;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Print the Observation, Process and Systematic entries to the screen</span></div>
<div class="line">  cmb1.<a class="code" href="classch_1_1_combine_harvester.html#a28d52375fa2e13d80b6db9aa8b10113b">PrintObs</a>().<a class="code" href="classch_1_1_combine_harvester.html#ac65ce5523ef5b0fdcab6c2c6d21b49f4">PrintProcs</a>().<a class="code" href="classch_1_1_combine_harvester.html#acee50a734519bf510935610238641b7d">PrintSysts</a>();</div>
</div><!-- fragment --><p> When parsing a datacard, CombineHarvester breaks down the information it contains into sets of objects, each represented by a C++ class. A <a class="el" href="classch_1_1_observation.html">ch::Observation</a> object stores the information about the observed data in a single category, and likewise <a class="el" href="classch_1_1_process.html">ch::Process</a> stores the information for one expected signal or background process in a category. A <a class="el" href="classch_1_1_systematic.html">ch::Systematic</a> object records the uncertainty value assigned to a particular process from a particular source.</p>
<dl class="section note"><dt>Note</dt><dd>Internally a CombineHarvester contains three vectors, one for each kind of object. It's the job of the <a class="el" href="classch_1_1_combine_harvester.html#aa65fe68ae736e6b612a9c35f42adf02f">ParseDatacard</a> method to build a new set of these objects, extract the mapped histograms, and append them to these vectors. The histogram extraction is done automatically using the mapping rules given in the datacard (the lines starting with <code>shape</code>). Once the mapped ROOT file has been located and opened, the relevant histograms are copied into their corresponding CombineHarvester objects.</dd></dl>
<p>Each object class stores a standard set of metadata, designed to aid in the filtering and selection of particular objects within a CombineHarvester, and which in the example above is specified explicitly. The possible metadata is listed in the following table.</p>
<table class="doxtable">
<tr>
<th align="center">name </th><th align="center">type </th><th align="center">example value  </th></tr>
<tr>
<td align="center">bin </td><td align="center">string </td><td align="center"><em>automatic</em> </td></tr>
<tr>
<td align="center">process </td><td align="center">string </td><td align="center"><em>automatic</em> </td></tr>
<tr>
<td align="center">analysis </td><td align="center">string </td><td align="center">"htt" </td></tr>
<tr>
<td align="center">era </td><td align="center">string </td><td align="center">"8TeV" </td></tr>
<tr>
<td align="center">channel </td><td align="center">string </td><td align="center">"mt" </td></tr>
<tr>
<td align="center">bin_id </td><td align="center">int </td><td align="center">6 </td></tr>
<tr>
<td align="center">mass </td><td align="center">string </td><td align="center">"125" </td></tr>
</table>
<p>Of these only <code>bin</code>, <code>process</code> and <code>mass</code> are tracked and used by combine, the others are optional and can be left empty if unneeded. The <code>bin</code> property is used to uniquely label an event category. Along with the process names, this is written directly into the datacard and is extracted automatically. The <code>mass</code> property is an exception: although we typically create a datacard for a particular signal mass hypothesis this information is not recorded in the datacard, but rather is passed to combine as a command line option, e.g. <code>combine -M Asymptotic -m 125 my_datacard.txt</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <code>mass</code> is not specified, <a class="el" href="classch_1_1_combine_harvester.html#aa65fe68ae736e6b612a9c35f42adf02f">ParseDatacard</a> is likely to fail as this property is often needed to map signal processes to histograms in the input ROOT file. You can tell if this property is needed by looking for the term <code>$MASS</code> in the <code>shapes</code> rules at the top of the text datacard.</dd></dl>
<p>An important concept is that the objects created from a datacard are not explicitly linked - each is completely independent. When it's necessary to determine which objects are related, e.g. if we ask for the total uncertainty on a particular process, CombineHarvester will determine this on-the-fly by matching up <a class="el" href="classch_1_1_process.html">ch::Process</a> and <a class="el" href="classch_1_1_systematic.html">ch::Systematic</a> objects that have identical metadata.</p>
<p>The last line of the code will print the information stored about the Observation, Process and Systematic entries that we've created. Like many CombineHarvester methods, these Print functions return a reference to the calling object, meaning they can be chained together to keep the code concise. The output will look like:</p>
<pre class="fragment">--------------------------------------------------------------------------------------------------------
mass   analysis  era    channel  bin                          id  process               rate       shape
--------------------------------------------------------------------------------------------------------
125    htt       8TeV   mt       muTau_vbf_loose              6   data_obs              76         1
--------------------------------------------------------------------------------------------------------
mass   analysis  era    channel  bin                          id  process          sig  rate       shape
--------------------------------------------------------------------------------------------------------
125    htt       8TeV   mt       muTau_vbf_loose              6   ggH              1    1.2171     1
125    htt       8TeV   mt       muTau_vbf_loose              6   qqH              1    3.5739     1
125    htt       8TeV   mt       muTau_vbf_loose              6   VH               1    0.029033   1
125    htt       8TeV   mt       muTau_vbf_loose              6   ZTT              0    50.212     1
125    htt       8TeV   mt       muTau_vbf_loose              6   QCD              0    10.788     1
125    htt       8TeV   mt       muTau_vbf_loose              6   W                0    22.544     1
125    htt       8TeV   mt       muTau_vbf_loose              6   ZL               0    0.23798    1
125    htt       8TeV   mt       muTau_vbf_loose              6   ZJ               0    1.9001     1
125    htt       8TeV   mt       muTau_vbf_loose              6   TT               0    2.0405     1
125    htt       8TeV   mt       muTau_vbf_loose              6   VV               0    0.7037     1
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
mass   analysis  era    channel  bin                          id  process          sig  nuisance                                      type     value         sh_d sh_u
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
125    htt       8TeV   mt       muTau_vbf_loose              6   ggH              1    lumi_8TeV                                     lnN      1.026         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   qqH              1    lumi_8TeV                                     lnN      1.026         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   VH               1    lumi_8TeV                                     lnN      1.026         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   qqH              1    pdf_qqbar                                     lnN      1.036         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   VH               1    pdf_qqbar                                     lnN      1.04          0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   ggH              1    pdf_gg                                        lnN      1.097         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   ggH              1    UEPS                                          lnN      0.893         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   qqH              1    UEPS                                          lnN      0.988         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   VH               1    UEPS                                          lnN      0.988         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   ggH              1    QCDscale_ggH2in                               lnN      0.772         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   qqH              1    QCDscale_qqH                                  lnN      1.018         0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   VH               1    QCDscale_VH                                   lnN      1.04          0    0
125    htt       8TeV   mt       muTau_vbf_loose              6   ggH              1    CMS_scale_t_mutau_8TeV                        shape    0.9513/1.093  1    1
125    htt       8TeV   mt       muTau_vbf_loose              6   qqH              1    CMS_scale_t_mutau_8TeV                        shape    0.9585/1.038  1    1
125    htt       8TeV   mt       muTau_vbf_loose              6   VH               1    CMS_scale_t_mutau_8TeV                        shape    0.9999/1      1    1
125    htt       8TeV   mt       muTau_vbf_loose              6   ZTT              0    CMS_scale_t_mutau_8TeV                        shape    0.9639/1.055  1    1
...
</pre><h1><a class="anchor" id="ex1-p2"></a>
Parsing multiple cards </h1>
<p>Next we create another CombineHarvester instance and parse several datacards, this time using a method in which the object metadata is inferred from the datacard filenames:</p>
<div class="fragment"><div class="line">  <a class="code" href="classch_1_1_combine_harvester.html">ch::CombineHarvester</a> cmb2;</div>
<div class="line">  <span class="comment">// Parse a set of datacards into one CombineHarvester instance</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">string</span> bin_id : {<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>}) {</div>
<div class="line">    cmb2.<a class="code" href="classch_1_1_combine_harvester.html#aa65fe68ae736e6b612a9c35f42adf02f">ParseDatacard</a>(in_dir + <span class="stringliteral">&quot;htt_mt_&quot;</span> + bin_id + <span class="stringliteral">&quot;_8TeV-125.txt&quot;</span>,</div>
<div class="line">                       <span class="stringliteral">&quot;$ANALYSIS_$CHANNEL_$BINID_$ERA-$MASS.txt&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
</div><!-- fragment --><p> In this ParseDatacard method only two arguments are required: the path to the text datacard and a string containing place-holders for the metadata. Note that there's no obligation to include all five place-holders in this string. Additionally, the place-holders are not restricted to appearing in the filename but may also be included in the preceding directory path, e.g. <code>$MASS/$ANALYSIS_$CHANNEL_$BINID_$ERA.txt</code> is also valid.</p>
<h1><a class="anchor" id="ex1-p3"></a>
Filtering </h1>
<p>Now let's pretend we are no longer interested in the first four categories we parsed. To remove objects we use a filter method. There are four generic filter methods: FilterAll, FilterObs, FilterProcs and FilterSysts that each accept a function, or function-type object that must have a single <a class="el" href="classch_1_1_object.html">ch::Object</a>, <a class="el" href="classch_1_1_observation.html">ch::Observation</a>, <a class="el" href="classch_1_1_process.html">ch::Process</a> or <a class="el" href="classch_1_1_systematic.html">ch::Systematic</a> pointer argument and return a bool. A <code>true</code> return value indicates that the object should be dropped. The FilterAll method will act on all three object collections whereas the others operate only on their respective collections. It's often convenient to write a small lambda function in-place:</p>
<div class="fragment"><div class="line">  <span class="comment">// Filter out all objects that do not have bin_id &lt;= 4</span></div>
<div class="line">  cmb2.<a class="code" href="classch_1_1_combine_harvester.html#aab08f8aee1553b76501ff1a4de0a716c">FilterAll</a>([](<a class="code" href="classch_1_1_object.html">ch::Object</a> <span class="keyword">const</span>* obj) {</div>
<div class="line">    <span class="keywordflow">return</span> obj-&gt;<a class="code" href="classch_1_1_object.html#ac57605a5c14ab76dc7be7ec7fa74be81">bin_id</a>() &lt;= 4;</div>
<div class="line">  });</div>
</div><!-- fragment --><p> Alternatively,there are a number of fixed-property filters, in which you need only supply a vector of the object properties you want to keep:</p>
<div class="fragment"><div class="line">  <span class="comment">// Another way to achieve the same effect</span></div>
<div class="line">  cmb2.<a class="code" href="classch_1_1_combine_harvester.html#a19106a6a89c84b90308b34672de6c187">bin_id</a>({5, 6, 7});</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Filter out all objects that have process name &quot;QCD&quot;</span></div>
<div class="line">  cmb2.<a class="code" href="classch_1_1_combine_harvester.html#a3afe330e302ad37b9fd69a821b8b4099">process</a>({<span class="stringliteral">&quot;QCD&quot;</span>}, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p> An optional boolean can be supplied as a second argument. When set to false this reverses the logic - objects with a property in the list will be dropped. In the second line we use this to remove all information about the QCD process. The full list of filter methods is found <a class="el" href="classch_1_1_combine_harvester.html#CH-Filters">here</a></p>
<h1><a class="anchor" id="ex1-p4"></a>
Yields, copying and sets </h1>
<p>In the final part of this example we take a look at the rate evaluation methods. These calculate the total event yields for either the observed data or the expected processes:</p>
<div class="fragment"><div class="line">  <span class="comment">// GetObservedRate() will sum the event yields of all remaining Observation</span></div>
<div class="line">  <span class="comment">// objects</span></div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Total observed rate:  &quot;</span> &lt;&lt; cmb2.<a class="code" href="classch_1_1_combine_harvester.html#a0b5444f9dcfa6fdace5fa2d8dc2ca11f">GetObservedRate</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// We can get the yield for a single bin by first making a shallow copy of the</span></div>
<div class="line">  <span class="comment">// current instance with the cp() method, then filtering this copy to leave</span></div>
<div class="line">  <span class="comment">// only the bin we&#39;re interested in, before finally calling GetObservedRate()</span></div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Single category rate: &quot;</span></div>
<div class="line">       &lt;&lt; cmb2.<a class="code" href="classch_1_1_combine_harvester.html#ade0f7c161d078a189404a274b93336d2">cp</a>().<a class="code" href="classch_1_1_combine_harvester.html#a83dd50569a1f1a4b5a46f2ad2b5c1cdb">bin</a>({<span class="stringliteral">&quot;muTau_vbf_loose&quot;</span>}).GetObservedRate() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// It is also possible to generate sets of object properties. Here we print</span></div>
<div class="line">  <span class="comment">// out the expected yield for each process in each bin</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> bin : cmb2.<a class="code" href="classch_1_1_combine_harvester.html#a869c951c635b86fba33b2c550c9c39c9">bin_set</a>()) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> proc : cmb2.<a class="code" href="classch_1_1_combine_harvester.html#ade0f7c161d078a189404a274b93336d2">cp</a>().<a class="code" href="classch_1_1_combine_harvester.html#a83dd50569a1f1a4b5a46f2ad2b5c1cdb">bin</a>({bin}).process_set()) {</div>
<div class="line">      cout &lt;&lt; bin &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; proc &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line">                        &lt;&lt; cmb2.<a class="code" href="classch_1_1_combine_harvester.html#ade0f7c161d078a189404a274b93336d2">cp</a>().<a class="code" href="classch_1_1_combine_harvester.html#a83dd50569a1f1a4b5a46f2ad2b5c1cdb">bin</a>({bin}).process({proc}).GetRate()</div>
<div class="line">                        &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Note that these functions are greedy - they will sum the contribution from every available Observation or Process entry. This means in the first line we get the total number of observed events in the three remaining categories. To get the yield for a single category we can prefix the function with a filter method. But here we must be careful, because we don't want to actually remove the information on the other categories permanently, which is what would happen if we just do: </p><pre class="fragment">cmb2.bin({"muTau_vbf_loose"}).GetObservedRate();
// cmb2 only contains objects for the "muTau_vbf_loose" category now!
</pre><p>To get around this we first call the <a class="el" href="classch_1_1_combine_harvester.html#ade0f7c161d078a189404a274b93336d2">cp</a> method on our CombineHarvester instance. This makes a shallow copy of the instance - in this it is only pointers to the contained objects, not the objects themselves, which are copied into a new instance. Such a copy is computationally fast to make, and we are free to filter objects from it without affecting the original instance at all.</p>
<dl class="section note"><dt>Note</dt><dd>Although filtering the objects in a shallow copy has no effect on the object lists in the original instance, both instances do still point to the same objects, so modifying the actual contents via the shallow copy will affect both instances. To create a full CombineHarvester copy, in which the underlying objects are also duplicated, use the <a class="el" href="classch_1_1_combine_harvester.html#acbc55586d0cc9e8dc83f0396157d4b75">deep</a> copy method instead.</dd></dl>
<p>The last part of the example code uses the CombineHarvester set-generating methods to conveniently loop through all defined (bin, process) combinations and print out the expected yield. The full list of available set-generating methods can be found <a class="el" href="classch_1_1_combine_harvester.html#CH-Set-Producers">here</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
</body>
</html>
